package systems.adaptix.bling.data

import scalikejdbc._

// TODO: EXISTS queries

/**
 * A SelectionCriterion represents a constraint to be imposed on a selection from a given table in a database. This corresponds to the argument to an SQL WHERE clause.
 * SelectionCriteria should be constructed using one of the following objects:
 * 1. [[systems.adaptix.bling.data.Eq]]
 * 2. [[systems.adaptix.bling.data.Ne]]
 * 3. [[systems.adaptix.bling.data.Lt]]
 * 4. [[systems.adaptix.bling.data.Le]]
 * 5. [[systems.adaptix.bling.data.Gt]]
 * 6. [[systems.adaptix.bling.data.Ge]]
 * 7. [[systems.adaptix.bling.data.Null]]
 * 8. [[systems.adaptix.bling.data.NotNull]]
 * 9. [[systems.adaptix.bling.data.In]]
 * 10. [[systems.adaptix.bling.data.And]]
 * 11. [[systems.adaptix.bling.data.Or]]
 * 12. [[systems.adaptix.bling.data.Not]]
 *
 * Alternatively, if you need to specify through a method argument that there are no selection criteria, please pass the [[systems.adaptix.bling.data.NoCriterion]] object.
 *
 * Created by nkashyap on 6/7/15.
 */
sealed trait SelectionCriterion {
  // TODO: There could be an issue here about how values are bound. Depends on the SQL parser. If parsing is done left-to-right, then what this method is doing now with compound constraints is alright.

  /**
   * Generates a String containing the SQL required to impose the constraint along with the variables to be bound to the SQL token when it is run on the database.
   * @return (constraint SQL String, variables bound to the SQL token)
   */
  def generateConstraints: (String, Seq[Any])

  /**
   * Returns the output of generateConstraints with the SQL String converted to scalikejdbc.SQLSyntax
   * @return (constraint SQLSyntax, variables bound to the SQL token)
   */
  def asSqlSyntaxWithValuesToBind: (SQLSyntax, Seq[Any]) = {
    val (constraints, values) = generateConstraints
    (SQLSyntax.createUnsafely(constraints), values)
  }
}


/**
 * This object signifies that there are no constraints to be placed upon a selection.
 */
object NoCriterion extends SelectionCriterion {
  def generateConstraints = ("", Seq())
}


/**
 * Eq generates a SelectionCriterion representing the constraint that the value in a given column be EQUAL to a given value.
 */
object Eq extends OrderConstraint

/**
 * Ne generates a SelectionCriterion representing the constraint that the value in a given column be NOT EQUAL to a given value.
 */
object Ne extends OrderConstraint

/**
 * Lt generates a SelectionCriterion representing the constraint that the value in a given column be LESS THAN a given value.
 */
object Lt extends OrderConstraint

/**
 * Le generates a SelectionCriterion representing the constraint that the value in a given column be LESS THAN OR EQUAL TO a given value.
 */
object Le extends OrderConstraint

/**
 * Gt generates a SelectionCriterion representing the constraint that the value in a given column be GREATER THAN a given value.
 */
object Gt extends OrderConstraint

/**
 * Ge generates a SelectionCriterion representing the constraint that the value in a given column be GREATER THAN OR EQUAL TO a given value.
 */
object Ge extends OrderConstraint

/**
 * The basis for the Eq, Ne, Lt, Le, Gt, Ge SelectionCriterion constructors.
 */
sealed trait OrderConstraint {
  def asString = this match {
    case Eq => "="
    case Ne => "<>"
    case Lt => "<"
    case Le => "<="
    case Gt => ">"
    case Ge => ">="
  }

  /**
   * @param column The name of the column which is being constrained.
   * @param value The value imposed by the constraint.
   * @return A SelectionCriterion object representing the desired constraint.
   */
  def apply(column: String, value: Any): SelectionCriterion = OrderCriterion(this, column, value)
}

/**
 * The SelectionCriterion generated by Eq, Ne, Lt, Le, Gt, Ge.
 * @param constraintType A reference to the generating object, which specifies the kind of order constraint being imposed.
 * @param column The name of the column which is being constrained.
 * @param value The value imposed by the constraint.
 */
final case class OrderCriterion(constraintType: OrderConstraint, column: String, value: Any) extends SelectionCriterion {
  def generateConstraints = (s"${column} ${constraintType.asString} ?", Seq(value))
}


/**
 * Null generates a SelectionCriterion representing the constraint that the value in a given column be NULL.
 */
object Null {
  def apply(column: String) = NullCriterion(true, column)
}

/**
 * NotNull generates a SelectionCriterion representing the constraint that the value in the given column NOT be NULL.
 */
object NotNull {
  def apply(column: String) = NullCriterion(false, column)
}

/**
 * The SelectionCriterion generated by Null and NotNull.
 * @param isNull Specifies whether the field in question is supposed to be Null or not.
 * @param column The name of the column which is being subjected to the constraint.
 */
final case class NullCriterion(isNull: Boolean, column: String) extends SelectionCriterion {
  def generateConstraints = (s"${column}" + {if (isNull) " IS NULL" else " IS NOT NULL"}, Seq[Any]())
}


/**
 * In generates a SelectionCriterion representing the constraint that the value in a given column be present in a specified selection
 * of columns from a given table (which may in turn be subject to its own [[systems.adaptix.bling.data.SelectionCriterion]]).
 */
object In {
  /**
   * @param column The column of the outer table the value of which should be in the inner selection.
   * @param tableName The name of the table from which the inner selection is being made.
   * @param tableColumns The column in the inner selection.
   * @param tableCriterion The [[systems.adaptix.bling.data.SelectionCriterion]] for the inner selection.
   * @return The SelectionCriterion representing the specified constraint.
   */
  // TODO: The column argument of the apply method should really be of type DesiredColumns (and should accept multiple columns).
  def apply(column: String, tableName: String, tableColumns: DesiredColumns = AllColumns, tableCriterion: SelectionCriterion = NoCriterion) = InCriterion(column, tableName, tableColumns, tableCriterion)
}

/**
 * The SelectionCriterion generated by In.
 * @param column The column of the outer table the value of which should be in the inner selection.
 * @param tableName The name of the table from which the inner selection is being made.
 * @param tableColumns The column in the inner selection.
 * @param tableCriterion The [[systems.adaptix.bling.data.SelectionCriterion]] for the inner selection.
 */
final case class InCriterion(column: String, tableName: String, tableColumns: DesiredColumns, tableCriterion: SelectionCriterion) extends SelectionCriterion {
  def generateConstraints = tableCriterion match {
    case NoCriterion => (s"${column} IN (SELECT ${tableColumns.asString} FROM ${tableName})", Seq[Any]())
    case _ => {
      val (criterionString, criterionValuesToBind) = tableCriterion.generateConstraints
      (s"${column} IN (SELECT ${tableColumns.asString} FROM ${tableName} WHERE ${criterionString})", criterionValuesToBind)
    }
  }
}

/**
 * An object of this type represents a collection of columns which one wishes to select from a table in a database.
 * A DesiredColumns objects is either the [[systems.adaptix.bling.data.AllColumns]] singleton object or it is of type [[systems.adaptix.bling.data.SomeColumns]].
 */
sealed trait DesiredColumns {
  def asString = this match {
    case AllColumns => "*"
    case desired: SomeColumns => desired.columns.mkString(", ")
  }
}

/**
 * Signifies that all columns in a table are desired. Equivalent to "*" in SQL.
 */
object AllColumns extends DesiredColumns

/**
 * Contains the names of the columns one desires selected from a table in some specific order.
 * @param columns A Seq[String] which specifies the desired selection format.
 */
final case class SomeColumns(columns: Seq[String]) extends DesiredColumns


/**
 * Constructs SelectionCriteria which are either conjunctions or disjunctions of other SelectionCriteria.
 * The two objects of Junction type are [[systems.adaptix.bling.data.And]] and [[systems.adaptix.bling.data.Or]].
 */
sealed trait Junction {
  /**
   * A String representation of the type of Junction.
   * @return "AND" for And and "OR" for Or.
   */
  def asString = this match {
    case And => "AND"
    case Or => "OR"
  }

  /**
   * @param componentCriteria The criteria which the caller desires to take a conjunction or disjunction of.
   * @return The SelectionCriterion generated by making the desired conjunction or disjunction.
   */
  def apply(componentCriteria: SelectionCriterion*): SelectionCriterion = new JunctiveCriterion(this, componentCriteria:_*)
}

/**
 * Conjunctive [[systems.adaptix.bling.data.Junction]].
 */
object And extends Junction

/**
 * Disjunction [[systems.adaptix.bling.data.Junction]].
 */
object Or extends Junction

/**
 * SelectionCriterion generated by And and Or.
 * @param junction Specifies whether a conjunction or disjunction is being made.
 * @param componentCriteria The SelectionCriterion over which the conjunction or disjunction is to be taken.
 */
final class JunctiveCriterion(junction: Junction, componentCriteria: SelectionCriterion*) extends SelectionCriterion {
  def generateConstraints = {
    val (componentStrings, componentValues) = componentCriteria.map(_.generateConstraints).unzip
    ( "(" + componentStrings.mkString(s") ${junction.asString} (") + ")" , ( componentValues :\ Seq[Any]() )(_ ++ _) )
  }
}


/**
 * Constructs a SelectionCriterion which is the negation of a given SelectionCriterion.
 */
object Not {
  /**
   * @param criterionToNegate The SelectionCriterion that the caller wishes negated.
   * @return The negated SelectionCriterion.
   */
  def apply(criterionToNegate: SelectionCriterion): SelectionCriterion = NegativeCriterion(criterionToNegate)
}

/**
 * SelectionCriterion generated by Not.
 * @param componentCriterion The SelectionCriterion to be negated.
 */
final case class NegativeCriterion(componentCriterion: SelectionCriterion) extends SelectionCriterion {
  def generateConstraints = {
    val (componentString, componentValues) = componentCriterion.generateConstraints
    ( s"NOT (${componentString})", componentValues)
  }
}
